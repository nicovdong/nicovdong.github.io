<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>基础概念(2) | Yuchuan Blog</title><meta name="description" content="基础概念(2)"><meta name="keywords" content="java"><meta name="author" content="董玉川"><meta name="copyright" content="董玉川"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="基础概念(2)"><meta name="twitter:description" content="基础概念(2)"><meta name="twitter:image" content="http://nicovdong.github.io/img/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="基础概念(2)"><meta property="og:url" content="http://nicovdong.github.io/java/base/java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5(2)/"><meta property="og:site_name" content="Yuchuan Blog"><meta property="og:description" content="基础概念(2)"><meta property="og:image" content="http://nicovdong.github.io/img/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://nicovdong.github.io/java/base/java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5(2)/"><link rel="prev" title="java-反射机制API" href="/http:/nicovdong.github.io/java/base/java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6API/"><link rel="next" title="reids环境配置" href="/http:/nicovdong.github.io/redis/redis-reids%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Yuchuan Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#OOP相关问题："><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">OOP相关问题：</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java-面向对象编程三大特性"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Java 面向对象编程三大特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重载和覆盖的区别"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">重载和覆盖的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#接口和抽象类的区别"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">接口和抽象类的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#内部类的种类"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">内部类的种类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#成员变量与局部变量的区别有那些？"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">成员变量与局部变量的区别有那些？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何获取父类的类名"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">如何获取父类的类名</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#this与super的区别"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">this与super的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是方法的返回值？返回值在类的方法里的作用是什么？"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">什么是方法的返回值？返回值在类的方法里的作用是什么？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#静态方法和实例方法有何不同？"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">静态方法和实例方法有何不同？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#泛型中extends和super的区别"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">泛型中extends和super的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#序列化"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">序列化</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OOP相关问题："><span class="toc-number">1.</span> <span class="toc-text">OOP相关问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-面向对象编程三大特性"><span class="toc-number">1.1.</span> <span class="toc-text">Java 面向对象编程三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载和覆盖的区别"><span class="toc-number">1.2.</span> <span class="toc-text">重载和覆盖的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口和抽象类的区别"><span class="toc-number">1.3.</span> <span class="toc-text">接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类的种类"><span class="toc-number">1.4.</span> <span class="toc-text">内部类的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量与局部变量的区别有那些？"><span class="toc-number">1.5.</span> <span class="toc-text">成员变量与局部变量的区别有那些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何获取父类的类名"><span class="toc-number">1.6.</span> <span class="toc-text">如何获取父类的类名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this与super的区别"><span class="toc-number">1.7.</span> <span class="toc-text">this与super的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是方法的返回值？返回值在类的方法里的作用是什么？"><span class="toc-number">1.8.</span> <span class="toc-text">什么是方法的返回值？返回值在类的方法里的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法和实例方法有何不同？"><span class="toc-number">1.9.</span> <span class="toc-text">静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型中extends和super的区别"><span class="toc-number">1.10.</span> <span class="toc-text">泛型中extends和super的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化"><span class="toc-number">1.11.</span> <span class="toc-text">序列化</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">基础概念(2)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-12-08<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-08</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/base/">base</a></span><div class="post-meta-wordcount"></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="OOP相关问题："><a href="#OOP相关问题：" class="headerlink" title="OOP相关问题："></a>OOP相关问题：</h1><h2 id="Java-面向对象编程三大特性"><a href="#Java-面向对象编程三大特性" class="headerlink" title="Java 面向对象编程三大特性"></a>Java 面向对象编程三大特性</h2><p><strong>封装、继承、多态</strong></p>
<p><strong>封装</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</span></pre></td></tr></table></figure>
<p><strong>继承</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</span></pre></td></tr></table></figure>
<p><strong>关于继承如下3点请记住：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">子类拥有父类非private的属性和方法。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">子类可以用自己的方式实现父类的方法。</span></pre></td></tr></table></figure>
<p><strong>多态</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</span></pre></td></tr></table></figure>

<h2 id="重载和覆盖的区别"><a href="#重载和覆盖的区别" class="headerlink" title="重载和覆盖的区别"></a>重载和覆盖的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. 覆盖是父类与子类之间关系，垂直关系；重载是同一个类中方法之间的关系，水平关系。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2. 覆盖只能有一个方法或者只能有一对方法产生关系；重载是多个方法之间的关系。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3. 覆盖要求方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">重载要求方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4. 覆盖关系中，调用方法体是根据对象的类型决定，重载是根据调用时的实参表与形参表来选择方法体的。</span></pre></td></tr></table></figure>

<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p><strong>相同点</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1.两者都不能实例化，但是可以定义引用变量指向实例对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2.两者的实现类或子类只有实现方法才能被实例化。</span></pre></td></tr></table></figure>
<p><strong>不同点</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. 定义关键字接口为interface,抽象类为abstract</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2. 接口只有定义，方法不能再接口中实现（1.8可以实现default修饰的方法）;而抽象类方法可以在抽象类中实现。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3. 接口的方法默认是public abstract,抽象类可以有非抽象的方法。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">4. 接口中的实例变量默认是public static final类型的，而且必须赋其初值；而抽象类中则不一定。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">5. 接口不能有静态方法和静态代码块，抽象类可以有。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">6. 一个类可以实现多个接口，但最多只能实现一个抽象类。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">7. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">8. 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</span></pre></td></tr></table></figure>
<blockquote>
<p>抽象类在被继承是体现的是is-a关系，强调所属关系，模版式设计；接口是can-do关系，强调特定功能实现，契约式设计。</p>
</blockquote>
<h2 id="内部类的种类"><a href="#内部类的种类" class="headerlink" title="内部类的种类"></a>内部类的种类</h2><p><strong>静态内部类：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">不能访问外部类的普通成员变量，只能访问外部类的静态成员和静态方法，包括私有类型。</span></pre></td></tr></table></figure>
<p><strong>成员内部类：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">自由的引用外部类的属性和方法，</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">**非静态内部类不能有静态成员，不可以定义静态属性和方法**。</span></pre></td></tr></table></figure>
<p><strong>局部内部类：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">似局部变量，不能被public、protected、private、static修饰，只能访问方法中定义为final类型的局部变量。</span></pre></td></tr></table></figure>
<p><strong>匿名内部类</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">没有类名，不能使用class、extends、implements,没有构造函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1)匿名内部类不能有构造方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2)匿名内部类不能定义静态成员、方法和类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3)匿名内部类不能是public、protected、private、static</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4)只能创建匿名内部类的一个实例</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">5)一个匿名内部类一定是在new后面，这个匿名类必须继承一个父类或者实现一个接口。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">6)局部内部类的所有限制对其生效。</span></pre></td></tr></table></figure>

<h2 id="成员变量与局部变量的区别有那些？"><a href="#成员变量与局部变量的区别有那些？" class="headerlink" title="成员变量与局部变量的区别有那些？"></a>成员变量与局部变量的区别有那些？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</span></pre></td></tr></table></figure>

<h2 id="如何获取父类的类名"><a href="#如何获取父类的类名" class="headerlink" title="如何获取父类的类名"></a>如何获取父类的类名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">getClass().getName()</span></pre></td></tr></table></figure>
<h2 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">this指向当前对象，super用于访问父类的方法或者成员变量。</span></pre></td></tr></table></figure>

<h2 id="什么是方法的返回值？返回值在类的方法里的作用是什么？"><a href="#什么是方法的返回值？返回值在类的方法里的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值在类的方法里的作用是什么？"></a>什么是方法的返回值？返回值在类的方法里的作用是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</span></pre></td></tr></table></figure>

<h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制.</span></pre></td></tr></table></figure>

<h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. &lt;? extends T&gt; 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2. &lt;? super T&gt;只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3. ? 既不能用于入参也不能用于返参</span></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. java原生序列化</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2. Hessian序列化</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3. Json序列化</span></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">董玉川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/http:/nicovdong.github.io/java/base/java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5(2)/">http://nicovdong.github.io/java/base/java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5(2)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://nicovdong.github.io">Yuchuan Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java    </a></div><div class="post_share"><div class="social-share" data-image="/img/default_bg.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/java/base/java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6API/"><img class="prev_cover lazyload" data-src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>java-反射机制API</span></div></a></div><div class="next-post pull_right"><a href="/redis/redis-reids%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><img class="next_cover lazyload" data-src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>reids环境配置</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/java/base/java-反射机制API/" title="java-反射机制API"><img class="relatedPosts_cover lazyload"data-src="/img/default_bg.png"><div class="relatedPosts_title">java-反射机制API</div></a></div><div class="relatedPosts_item"><a href="/java/base/java-基础概念(1)/" title="基础概念(1)"><img class="relatedPosts_cover lazyload"data-src="/img/default_bg.png"><div class="relatedPosts_title">基础概念(1)</div></a></div><div class="relatedPosts_item"><a href="/java/base/java-基础概念(3)/" title="基础概念(3)"><img class="relatedPosts_cover lazyload"data-src="/img/default_bg.png"><div class="relatedPosts_title">基础概念(3)</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 By 董玉川</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>